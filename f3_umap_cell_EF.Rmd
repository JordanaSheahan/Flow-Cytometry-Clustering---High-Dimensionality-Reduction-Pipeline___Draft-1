---
title: "f3_umap_cell"
author: "Edison Foo"
date: "2024-01-22"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
setwd("W:/Research Focus Areas/Early Environment/Bacterial Respiratory Infectious Disease Group/Study_RFA Collab 2022 Spectral Flow/Manuscripts/Spectral Methods paper/Figure 3")
library(job)
library(Spectre)
```

## Introduction

In a full-spectrum flow cytometry panel, detector optimisation is very important for achieving high quality unmixed FCM data. There are different methods to calibrating the detectors.

In order to assess the quality of each unmixing methods, we will use dimensionality reduction on three splenocyte samples acquired from FACSymphony A5 SE which has been optimised with the 4 different methods. For each method, we will examine whether the native cellular phenotypes have been preserved. Compensated data on the same samples will be used as reference.

## Importing and Prepping Data

Samples have been gated for cells, doublets, time, live, CD45+, in FlowJo and then exported as CSV with scale values.

To check the imported data, use```name.table```. It is a table of all the column names for all of your samples (one row per sample, one column per column name). If all of the column names are matching, then this table should be a repeating pattern.

```{r import}
# Should number 24 (8 methods x 3 samples each)
data.list <- Spectre::read.files(file.loc = "rsc/CSV_files",
                                 file.type = ".csv",
                                 do.embed.file.names = TRUE)

# Check the data
check <- do.list.summary(data.list)
check$name.table # Review column names and their subsequent values
check$ncol.check # Review number of columns (features, markers) in each sample
check$nrow.check # Review number of rows (cells) in each sample
data.list[[1]]

# Import metadata
meta.dat <- fread("rsc/CSV_metadata/sample_details.csv")
```

## Concantenate 

UMAP are both inherently non-deterministic algorithms, and so direct comparisons can only be made within one data set. To do this, we have to concatenate (combine with ability to separate) data from samples of interest when importing. 

```{r pressure, echo=FALSE}
cell.dat <- Spectre::do.merge.files(dat = data.list)
cell.dat <- do.add.cols(cell.dat, "FileName", meta.dat, "Filename", rmv.ext = TRUE)
as.matrix(names(cell.dat)) # Check column names
cell.dat                   # Check table

saveRDS(cell.dat, file = "rsc/cell_data.rds" )
```
## Data Transformation

Before we perform clustering etc, we need to meaningfully transform the data. We will use logicle from FlowSOM to transform the concatenated data

``` {r transform}
# Load checkpoint
cell.dat <- readRDS("rsc/cell_data.rds")

# Specify columns to transform
to.logicle <- names(cell.dat)[c(7:21)] 



# transformed.dat <- do.logicle(cell.dat,
#                               to.logicle,
#                               auto.infer.function=TRUE)

transformed.dat <- do.logicle(cell.dat,
                       to.logicle,
                       auto.infer.function=FALSE,
                       linearisation.width=1.2,
                       max.scale.val=200000,
                       full.transform.width=8,
                       additional.negative.range=0)

# Plotting the transformed data to check
plot.against <- "FSC-A" # column to plot transformed results

transformed.cols <- paste0(to.logicle, "_logicle")

for(i in transformed.cols){
  print(make.colour.plot(do.subsample(transformed.dat, 5000), i, plot.against))
}

# Checkpoint
saveRDS(transformed.dat, file = "rsc/transformed_data.rds" )


```

## Clustering

Cluster the data to identify populations that partition together as similar cells in high-dimensional space. Initially, we identify parameters - used for both clustering analysis and for the dimensionality reduction. We will FlowSOM  for cluster analysis and save these in their respective objects.

``` {r clustering}
cluster.cols <- names(transformed.dat)[c(25:39)] # Subset of transformed columns
as.matrix(cluster.cols) # Checking

#Subsampling

sub.target <- c(20000,20000,20000,20000,20000,20000,20000,20000) # Number of cells per group
group.col <- "Group" # unique(cell.dat[[group.col]]) to list present groups
transformed.dat.sub <- do.subsample(transformed.dat, sub.target, group.col)

# meta.k is the number of clusters
  #clustered.dat <- run.flowsom(transformed.dat, cluster.cols, meta.k = 12)
  clustered.dat <- run.phenograph(dat = transformed.dat.sub, k=60,  use.cols = cluster.cols)
  
  saveRDS(clustered.dat, file = "Output/clustered_dat.rds" )
  colnames(clustered.dat)


job({
  
})

# job({
#   transformed.dat.sub.cluster <- transformed.dat.sub[,cluster.cols]
#   Rphenograph_out <- Rphenograph(transformed.dat.sub.cluster, k = 60)
#   saveRDS(Rphenograph_out, file = "Output/Rphenograph_out.rds" )
#   colnames(Rphenograph_out)
# })


```

## Dimensionality Reduction

To visualise cell subsets defined by flowSOM, we will embed the high dimensional data in two dimensional space, using uniform manifold approximation and projection embedding (UMAP).

We will then separate each plot each UMAP by their method and compensation vs unmixing
``` {r}
# group.col <- "Group" # unique(cell.dat[[group.col]]) to list present groups
# sub.target <- c(20000,20000,20000,20000,20000,20000,20000,20000) # Number of cells per group
# cell.sub <- do.subsample(clustered.dat, sub.target, group.col)
# cell.sub # Check correct dimensions


umap.sub <- run.umap(clustered.dat, cluster.cols)
saveRDS(umap.sub, "rsc/umap.sub")


make.colour.plot(umap.sub, "UMAP_X", "UMAP_Y", "Phenograph_cluster", col.type = 'factor', add.label = TRUE)
make.multi.plot(umap.sub, "UMAP_X", "UMAP_Y", "Phenograph_cluster", group.col, col.type = 'factor')


```

## Plotting

Plot Results from each method (unmixed or compensated) x (mdfl-optimised || 10^2 || peak || rsden)

``` {r plot}
library(cowplot)

groups <- unique(cell.dat[[group.col]])

samplelist <- vector(mode = "list", 3)
for (i in groups) {
  samplelist[[i]] <- umap.sub[umap.sub$Group == i,]
}

subsetplots <- function(i) {
                            ggplot(samplelist[[i]], aes(
                              x = UMAP_X,
                              y = UMAP_Y,
                              #colour = factor(Cell_ID)
                                                          )) +
                              # ggtitle(names(samplelist[i])) +
                              ylim(-8,10) + xlim(-18,10) +
                              geom_point(size = 1, show.legend = TRUE) +
                              theme_classic() + xlab("UMAP X") + ylab("UMAP Y") +
                              theme(legend.text = element_text(size = 12),
                                    legend.position = "none") +
                              guides(colour = guide_legend(override.aes = list(size = 5), ncol = 2))
                            }

# Iterate function across the two datasets
multiplot <- lapply(groups, subsetplots)
p3 <- plot_grid(plotlist = multiplot,
                ncol = 4,
                align = "hv",
                label_size = 14
                )
p3

comp_midfl <- umap.sub[umap.sub$Group == "comp_midfl",]
ggplot(comp_midfl, aes(x = UMAP_X, y = UMAP_Y)) +
      geom_point(size = 1, show.legend = TRUE) +
      theme_classic() + xlab("UMAP X") + ylab("UMAP Y")


```

