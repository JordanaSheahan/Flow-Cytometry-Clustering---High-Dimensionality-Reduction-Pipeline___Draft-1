---
title: "Clustering and High Dimensionality Masterscript 09/04/2024"
output: html_notebook
editor_options: 
  chunk_output_type: inline
---

This is an [R Markdown](http://rmarkdown.rstudio.com) Notebook. When you execute code within the notebook, the results appear beneath the code. 

Try executing this chunk by clicking the *Run* button within the chunk or by placing your cursor inside it and pressing *Ctrl+Shift+Enter*. 

```{r}
plot(cars)
```

Add a new chunk by clicking the *Insert Chunk* button on the toolbar or by pressing *Ctrl+Alt+I*.

When you save the notebook, an HTML file containing the code and output will be saved alongside it (click the *Preview* button or press *Ctrl+Shift+K* to preview the HTML file).

The preview shows you a rendered HTML copy of the contents of the editor. Consequently, unlike *Knit*, *Preview* does not run any R code chunks. Instead, the output of the chunk when it was last run in the editor is displayed.

Notes prior to commencing project: 
- It is recommended to review individual vignettes for packages Spectre, Cytofkit2 and CytoNorm.
- Samples should be gated for cells, doublets, time, live, fluorophore aggregates and main target cell subset in FlowJo and then exported as CSV with scale values.
- Initial data file import is in csv format into Spectre. Transfer from Spectre to Cytofkit2 involves conversion back into fcs file format. Metadata is required to be saved in a separate csv file. File naming for csv sample files should be in a format that includes sample type (case/control/reference control), sample identifier and batch reference number. To quickly rename files, use script provided below in pre-setup. See Spectre vignette for further information: https://wiki.centenary.org.au/display/SPECTRE/Discovery+workflow+with+batch+alignment+using+CytoNorm 
- As processing can take some time with large data files, it is recommended to use data file save points throughout this script if you wish to return to script later. These are marked "#Checkpoint"

#Pre-Setup
```{r}
# Pre-setup required if csv file names are not in an appropriate format for processing
# Label mapping csv file required to change bulk file names

# Load necessary libraries
library(readr)

# Specify the paths to the CSV mapping file and the folder with CSV files
csv_mapping_file <- "W:/Collaborative Projects/BSNRF/Spectre/label_mapping.csv"
folder_with_csv_files <- "W:/Collaborative Projects/BSNRF/Spectre/raw_data_export"

# Read the CSV mapping file
mapping_data <- read.csv(csv_mapping_file, header = FALSE, stringsAsFactors = FALSE, col.names = c("old_label", "new_label"))

# Print the mapping data
print(mapping_data)

# Rename files based on the mapping
for (i in 1:nrow(mapping_data)) {
  old_label <- mapping_data$old_label[i]
  new_label <- paste(mapping_data$new_label[i], ".csv", sep = "")
  
  old_path <- file.path(folder_with_csv_files, old_label)
  new_path <- file.path(folder_with_csv_files, new_label)
  
  # Print file paths for debugging
  cat("Old Path:", old_path, "\n")
  cat("New Path:", new_path, "\n")
  
  # Check if the file exists before renaming
  if (file.exists(old_path)) {
    # Rename the file
    file.rename(old_path, new_path)
    cat("Renamed:", old_label, "to", new_label, "\n")
  } else {
    cat("File not found:", old_label, "\n")
  }
}


```


#First Stage: Setup, Transformation and Batch Alignment using Spectre Package
#1. Load Packages and Set Working Directory
```{r}

### Install CytoNorm package
     
      library(devtools)
        install_github('saeyslab/CytoNorm')
 
### Load libraries
 
        library(Spectre)
        Spectre::package.check()    # Check that all required packages are installed
        Spectre::package.load()     # Load required packages
        
        
### Set PrimaryDirectory
    dirname(rstudioapi::getActiveDocumentContext()$path) # Finds the directory where this script is located
    setwd(dirname(rstudioapi::getActiveDocumentContext()$path)) # Sets the working directory to where the script is located
    
    getwd()
    PrimaryDirectory <- getwd()
    PrimaryDirectory
    
    
### Set 'input' directory
    setwd(PrimaryDirectory)
    setwd("data/")
    InputDirectory <- getwd()
    setwd(PrimaryDirectory)  
    
### Set 'metadata' directory
    setwd(PrimaryDirectory)
    setwd("metadata/")
    MetaDirectory <- getwd()
    setwd(PrimaryDirectory)   
    
    
### Create output directory
    dir.create("Output_Spectre", showWarnings = FALSE)
    setwd("Output_Spectre")
    OutputDirectory <- getwd()
    setwd(PrimaryDirectory) 



```


#2. Data Import and File Merge
```{r}

### Import data
 
    setwd(InputDirectory)
    list.files(InputDirectory, ".csv")
    

### "here()" is quick way to reference file path
setwd("data/")
data.list <- Spectre::read.files(file.loc = here("data"), 
                                 file.type = ".csv",
                                do.embed.file.names = TRUE)


### Check the data
 
    check <- do.list.summary(data.list)
 
    check$name.table # Review column names and their subsequent values
    check$ncol.check # Review number of columns (features, markers) in each sample
    check$nrow.check # Review number of rows (cells) in each sample
    
    

data.list[[1]]



### Merge data
 
    cell.dat <- Spectre::do.merge.files(dat = data.list)
    
    
    cell.dat


### Read in metadata 
    setwd("metadata/")
    
    here::here("metadata")
    meta.dat <- fread("sample.details.csv")
    meta.dat
```


#3. Logicle Data Transformation
```{r}

 #Reference directory

setwd(OutputDirectory)
    dir.create("Output 1 - Data Transformation")
    setwd("Output 1 - Data Transformation") 
    dir.create("Pre-transformation plots")
    setwd("Pre-transformation plots")
    
 #Pre-transformation plots to be saved and compared to transformed plots after
    
    
   sub <- do.subsample(cell.dat, 10000)
    
        as.matrix(names(sub))
 
transf.cols <- names(sub)[grepl('Ig|CX|CD|BAFF|HLA', names(sub))] #Marker iterations
as.matrix(transf.cols)

   plot.against <- 'CD19 BUV805'       # Choose y-axis marker for each plot common to all
   which(names(sub) == plot.against)   # Check selected marker present
 
   for(i in transf.cols){
      make.colour.plot(sub, i, plot.against)
   } 
   
   
#Reference directory for transformation   
setwd("Output 1 - Data Transformation") 
    dir.create("Transformation plots")
    setwd("Transformation plots")
   
#Begin setup for transformation
    
    use.cols = names(cell.dat)[c(3:26)]
    dat.lgcl = do.logicle(cell.dat, use.cols = use.cols)
    
#Determine correct linearisation.width to use for your dataset using equation:  
    #(m-log10(262144/|r|))/2
    #where r is most negative value of data for each marker
    #and m is linearisation.width (slope of transformation at x=0)
    
  #Find r for each channel using function to find most negative values in each column:
  most_negative <- function(column) {
   min_value <- min(column)
   return(min_value)
  }

  # Create linearisation width equation
  calculate_equation <- function(m, r) {
   result <- (m - log10(262144/abs(r)))/2  #Assuming default 262144 for flow cytometry data
   return(result)
  }

  # Loop through each channel to find r and calculate linearisation width (m)
  for (col in use.cols) {
  m <- most_negative(cell.dat[[col]])
  r <- m # Use the most negative value as r
  result <- calculate_equation(m, r)
  print(paste("For column", col, "with m =", m, ", result is:", result))
  }
    
  #Assess output for each channel and decide if manual adjustment of linearisation.width required
  
    do.logicle <- function(cell.dat, 
                       use.cols,
                       auto.infer.function = FALSE, #TRUE if manual adjustment not required
                       linearisation.width = 1.2, #adjust to avoid false peaks
                       max.scale.val = 262144, #default 262144 for flow cytometry data
                       full.transform.width = 4.5,
                       additional.negative.range = 0) {
  
  require(flowCore)
  require(Biobase)
  require(data.table)
  
  # check selected columns are numeric
  if(any(unlist(lapply(dat[, use.cols, with = FALSE], is.numeric)) == FALSE)) {
    stop('Non-numeric columns are selected for transformation. Please exclude them.')
  }
  
  values <- dat[,use.cols, with=FALSE]
  
  val.mat <- as.matrix(values)
  
  ff <- new("flowFrame", exprs = val.mat)
  
  if (auto.infer.function) {
    # Automatic estimated logicle function
    message("Automatically estimating the logicle transformation function based on input data")
    lgcl <- estimateLogicle(ff, channels = use.cols) 
  } else {
    
    # check parameter conditions, make sure they are greater than 0
    if (is.null(max.scale.val) || max.scale.val <= 0) {
      stop('max.scale.val must be greater than 0')
    }
    if (is.null(linearisation.width) || linearisation.width <= 0) {
      stop('linearisation.width must be greater than 0')
    }
    if (is.null(full.transform.width) || full.transform.width <= 0) {
      stop('full.transform.width must be greater than 0')
    }
    
    # User defined logicle function
    message("Formulating logicle transformation function")
    trans_lgcl <- logicleTransform(w = linearisation.width, 
                                   t = max.scale.val, 
                                   m = full.transform.width, 
                                   a = additional.negative.range)
    lgcl <- transformList(use.cols, trans_lgcl)
  }
  
  # Do transformation
  message("Transforming data")
  trans.val <- flowCore::transform(ff, lgcl)
  
  message("Converting data back to data.table")
  trans.val.dt <- data.table(exprs(trans.val))
  names(trans.val.dt) <- paste(names(trans.val.dt), "logicle", sep = "_")
  
  dat_copy <- cbind(dat, trans.val.dt)
  return(dat_copy)
}

    
    # Make plots of transformed columns from the subsampled data
    

   sub <- do.subsample(dat.lgcl, 10000)
    
        as.matrix(names(sub))
 
transf.cols <- names(sub)[grepl('_logicle', names(sub))]
as.matrix(transf.cols)

   plot.against <- 'CD19 BUV805_logicle'       # Choose the y-axis column for each plot
   which(names(sub) == plot.against)       # Check that the selected column name is actually present
 
   for(i in transf.cols){
      make.colour.plot(sub, i, plot.against)
   }
   getwd()
   
   fwrite(dat.lgcl, 'logicle_transformed_cell.dat.csv')
   
   cell.dat <- dat.lgcl
   rm(dat.lgcl)

```

#### 4. Add metadata and set some preference
```{r}

### Add metadata to data.table
 
    meta.dat


sample.info <- meta.dat[,c(1:4)]
sample.info

cell.dat <- dat.lgcl

cell.dat <- do.add.cols(cell.dat, "FileName", sample.info, "FileName", rmv.ext = TRUE)


cell.dat

### Define cellular columns
    as.matrix(names(cell.dat))
    

### Define cellular columns
 
    as.matrix(names(cell.dat))
 
    cellular.cols <- names(cell.dat)[c(29:52)] #Define expression data columns here that you would like to cluster
    as.matrix(cellular.cols)
    
### Define clustering columns   
      
     as.matrix(names(cell.dat))
 
     cluster.cols <- names(cell.dat)[c(29, 33:36, 38, 40, 42:44, 46:52)] #Define markers you want to use to make cluster
     as.matrix(cluster.cols)
     
     
### Define other key columns
     
    as.matrix(names(cell.dat))
 
    exp.name <- "MS experiment" #Give your experiment a name
     
    sample.col <- "Sample"
    group.col <- "Group"
    batch.col <- "Batch"
    
    
### Subsample targets per group
 
    data.frame(table(cell.dat[[group.col]])) # Check number of cells per sample.
    
 as.matrix(unique(cell.dat[[group.col]]))
 
 sub.targets <- c(50000, 50000, 50000) # target subsample numbers from each group
sub.targets

```


#### 5. Batch alignment
```{r}

#### Batch alignment using CytoNorm

setwd(OutputDirectory)
dir.create("Output 2 - alignment")
setwd("Output 2 - alignment")

### Extract reference samples
     
    sample.info
    
    as.matrix(unique(cell.dat[[sample.col]]))
    refs <- unique(cell.dat[[sample.col]])[c(29:37)]
refs
ref.dat <- do.filter(cell.dat, sample.col, refs)
ref.dat

### Initial clustering
     
    setwd(OutputDirectory)
    setwd("Output 2 - alignment")
    dir.create("1 - ref pre-alignment")
    setwd("1 - ref pre-alignment")
    
 ###Edits to the source code of Cytonorm made below are required to make Cytonorm compatible with Spectre package versions currently used. This should resolve issues with matrix() package incompatibilities.
###Need to cut and paste source code from script text files saved with this masterscript into source code pop up so that the versions are compatible.
    
    trace(FlowSOM::AggregateFlowFrames, edit = T) ##replace all & with && (SEE EDITED SOURCE CODE TEXT FILE: "prep.cytonorm source code edit.txt")

 cytnrm <- prep.cytonorm(dat = ref.dat,
                        cellular.cols = cellular.cols,
                        cluster.cols = cluster.cols,
                        batch.col = batch.col,
                        sample.col = sample.col)        
 
cytnrm


cytnrm.sub <- do.subsample(cytnrm$dt, 10000)
cytnrm.sub <- run.umap(cytnrm.sub, use.cols = cluster.cols)

make.colour.plot(cytnrm.sub, 'UMAP_X', 'UMAP_Y', 'prep.fsom.metacluster', 'factor', add.label = TRUE)


make.colour.plot(cytnrm.sub, 'UMAP_X', 'UMAP_Y', 'File', 'factor')


### Train and Run Batch Alignment
     
    setwd(OutputDirectory)
    setwd("Output 2 - alignment")
    
    trace(Spectre::train.cytonorm, edit = T) #make sure all iterations of model$fsom actually replaced with model$fsom$FlowSOM (SEE EDITED SOURCE CODE TEXT FILE: "train.cytonorm source code edit.txt")
    
 cytnrm <- train.cytonorm(model = cytnrm, align.cols = cellular.cols)   
 
  
 trace(Spectre::run.cytonorm, edit = T) #make sure all iteration of model$fsom actually replaced with model$fsom$FlowSOM (SEE EDITED SOURCE CODE TEXT FILE: "run.cytonorm source code edit.txt")
cell.dat <- run.cytonorm(dat = cell.dat, model = cytnrm, batch.col = batch.col)
  
  
aligned.cols <- paste0(cellular.cols, '_aligned')

setwd(OutputDirectory)
     setwd("Output 2 - alignment")
     dir.create("3 - all aligned")
     setwd("3 - all aligned")

###Save Batch Aligned data as csv file
     
fwrite(cell.dat, 'aligned.cell.dat.csv')

### Plotting reference data
     
    setwd(OutputDirectory)
    setwd("Output 2 - alignment")
    dir.create("2 - ref aligned")
    setwd("2 - ref aligned")
    
    
    
    ref.sub <- do.filter(cell.dat, sample.col, refs)
ref.sub



ref.sub <- do.subsample(ref.sub, 50000)
ref.sub <- run.umap(ref.sub, use.cols = aligned.cols)



make.colour.plot(ref.sub, 'UMAP_X', 'UMAP_Y', batch.col, 'factor')


make.colour.plot(ref.sub, 'UMAP_X', 'UMAP_Y', 'Alignment_MC_aligned', 'factor', add.label = TRUE)


make.colour.plot(ref.sub, 'UMAP_X', 'UMAP_Y', sample.col, 'factor')


make.colour.plot(ref.sub, 'UMAP_X', 'UMAP_Y', group.col, 'factor')



### Plotting all data
      
     setwd(OutputDirectory)
     setwd("Output 2 - alignment")
     dir.create("3 - all aligned")
     setwd("3 - all aligned")
     
     
     aligned.sub <- do.subsample(cell.dat, 50000)
aligned.sub <- run.umap(aligned.sub, use.cols = aligned.cols)


make.colour.plot(aligned.sub, 'UMAP_X', 'UMAP_Y', batch.col, 'factor')


make.colour.plot(aligned.sub, 'UMAP_X', 'UMAP_Y', 'Alignment_MC_aligned', 'factor', add.label = TRUE)


make.colour.plot(aligned.sub, 'UMAP_X', 'UMAP_Y', sample.col, 'factor')

make.colour.plot(aligned.sub, 'UMAP_X', 'UMAP_Y', group.col, 'factor')



fwrite(aligned.sub, 'aligned.sub.csv')

```



###Important Note: From this point, the decision can be made regarding whether to continue using Spectre/FlowSOM or Cytofkit2/PhenoGraph for clustering, dimensional reduction and subsequent visualisation. Things to consider to assist with this decision: number of samples affects run time (Phenograph has high run time and RAM requirements compared to FlowSOM for high n), number of parameters (Phenograph is more suitable than FlowSOM for greater nuance and complexity in samples and hence may be more suitable for larger number of expression markers and/or for spectral flow cytometry data, but again run time needs to be considered for greater number of expression markers). For cluster number expected value of k<20, FlowSOM may be more suitable. For cluster number expected value k>20, PhenoGraph may be more suitable. In addition, for defining cell subsets from samples of general lymphocytes/monocytes/DCs, FlowSOM may be more efficient. However, for defining cell subsets within specific groups (e.g. B cell subsets), PhenoGraph may be more effective. If decided Cytofkit2/Phenograph to be applied, skip to line777 or 7.a chunk and continue using object cell.dat which will contain your aligned and transformed data. Otherwise continue below for FlowSom/Spectre.


#### 6.a. Spectre Clustering and dimensionality reduction using FlowSOM
```{r}

setwd(OutputDirectory)
dir.create("Output 3 - clustering")
setwd("Output 3 - clustering")


### Re-set cellular and clustering cols
 
    aligned.cellular.cols <- paste0(cellular.cols, '_aligned')
    aligned.cellular.cols
     
    aligned.cluster.cols <- paste0(cluster.cols, '_aligned')
    aligned.cluster.cols
    
    
### Clustering
 
    cell.dat <- run.flowsom(cell.dat, aligned.cluster.cols, meta.k = 50)
    fwrite(cell.dat, "clustered.data.csv")
    
    

### Dimensionality reduction
 
    cell.sub <- do.subsample(cell.dat, sub.targets, group.col)
    cell.sub <- run.umap(cell.sub, aligned.cluster.cols)
 
    fwrite(cell.sub, "clustered.data.DR.csv")
    
    

### DR plots
 
    make.colour.plot(cell.sub, "UMAP_X", "UMAP_Y", "FlowSOM_metacluster", col.type = 'factor', add.label = TRUE)
    
    make.multi.plot(cell.sub, "UMAP_X", "UMAP_Y", aligned.cellular.cols)
    
    make.multi.plot(cell.sub, "UMAP_X", "UMAP_Y", "FlowSOM_metacluster", group.col, col.type = 'factor')

### Expression heatmap
 
    exp <- do.aggregate(cell.dat, aligned.cellular.cols, by = "FlowSOM_metacluster")
    make.pheatmap(exp, "FlowSOM_metacluster", aligned.cellular.cols)

```

###6.b. Spectre Clusters: Annotate Clusters
```{r}
#Annotate Clusters
cell.dat <- fread("clustered.data_edited.csv")
cell.sub <- fread("clustered.data.DR_edited.csv")
setwd(OutputDirectory)
dir.create("Output 4 - annotation")
setwd("Output 4 - annotation")

### Annotate according to own data, here is my example:
 
    annots <- list("1_12_19_20_IgG1+ swMBC" = c(1, 12, 19, 20),
                   "2_15_18_22_33_37_38_39_43_47_Unknown" = c(2, 15, 18, 22, 33, 37, 38, 39, 43, 47),
                   "3_IgG+ MBC" = c(3),
                   "4_CD71hi IgA+ SwMBC" = c(4),
                   "5_6_Plasmablasts" = c(5, 6),
                   "7_16_21_Atypical CD11c+ CD21lo" = c(7, 16, 21),
                   "8_9_10_32_42_44_Naive B cells" = c(8, 9, 10, 32, 42, 44),
                   "11_CXCR3+ IgG+ swMBC" = c(11),
                   "13_IgG1 MBC" = c(13),
                   "14_IgG+ CD86hi CD71hi swMBC" = c(14),
                   "17_23_25_IgG2+ swMBC" = c(17, 23, 25),
                   "24_IgG+ swMBC" = c(24),
                   "26_27_28_30_31_IgA+ swMBC" = c(26, 27, 28, 30, 31),
                   "29_48_49_MZB" = c(29, 48, 49),
                   "34_35_36_41_IgM+ swMBC" = c(34, 35, 36, 41),
                   "40_CXCR3+CXCR5+ Naive B cell" = c(40),
                   "45_46_50_Transitional B cells" = c(45, 46, 50)
                   
                   
    )
    
    annots <- do.list.switch(annots)
names(annots) <- c("Values", "Population")
setorderv(annots, 'Values')
annots

### Add annotations

    cell.dat <- do.add.cols(cell.dat, "FlowSOM_metacluster", annots, "Values")
    cell.dat
     
    cell.sub <- do.add.cols(cell.sub, "FlowSOM_metacluster", annots, "Values")
    cell.sub

    
    
### Fill in NAs
      
     cell.dat[['Population']][is.na(cell.dat[, 'Population'])] <- 'Other'
     cell.dat
      
     cell.sub[['Population']][is.na(cell.sub[, 'Population'])] <- 'Other'
     cell.sub

     
     
### Save data and plots
     
    fwrite(cell.dat, "Annotated.data.csv")
    fwrite(cell.sub, "Annotated.data.DR.csv")
    
    make.colour.plot(cell.sub, "UMAP_X", "UMAP_Y", "Population", col.type = 'factor', add.label = TRUE, plot.width = 10, plot.height = 10, legend.loc = "bottom")
    
    do.filter(cell.sub, use.col = "Group", values = c("MS", "HC"))
make.multi.plot(cell.sub, "UMAP_X", "UMAP_Y", "Population", group.col, col.type = 'factor', plot.width = 20, plot.height = 20)
#Make multiplot by batch
make.multi.plot(cell.sub, "UMAP_X", "UMAP_Y", "Population", batch.col, col.type = 'factor', plot.width = 20, plot.height = 20)

### Expression heatmap
     #Temporarily redefine cellular.cols:
 as.matrix(names(cell.dat))
 
    cellular.cols <- names(cell.dat)[c(4:27)]
    as.matrix(cellular.cols)
    aligned.cellular.cols <- cellular.cols

    rm(exp)
    exp <- do.aggregate(cell.dat, aligned.cellular.cols, by = "Population")
    make.pheatmap(exp, "Population", aligned.cellular.cols)
    
    
    
    
### Write FCS files if wish to visualise in FlowJo
     
    setwd(OutputDirectory)
    setwd("Output 4 - annotation")
     
    dir.create('FCS files')
    setwd('FCS files')
     
    write.files(cell.dat,
                file.prefix = exp.name,
                divide.by = sample.col,
                write.csv = FALSE,
                write.fcs = TRUE)
    

```

###7.c. Spectre Summary data, graphs, statistics
```{r}

setwd(OutputDirectory)
dir.create("Output 5 - summary data")
setwd("Output 5 - summary data")

### Setup
 
    variance.test <- 'kruskal.test'
    pairwise.test <- "wilcox.test"
 
    comparisons <- list(c("HC", "MS"))
    comparisons
     
    grp.order <- c("HC", "MS")
    grp.order
    
    
### Select columns to measure MFI
 
    as.matrix(aligned.cellular.cols)
    dyn.cols <- aligned.cellular.cols[c(1:24)]
    dyn.cols
    
    sum.dat <- create.sumtable(dat = cell.dat,
                           sample.col = sample.col,
                           pop.col = "Population",
                           use.cols = dyn.cols,
                           annot.cols = c(group.col, batch.col)
                           #counts = counts
                           )
    
    ### Review summary data
     
    sum.dat
    as.matrix(names(sum.dat))
    
    annot.cols <- c(group.col, batch.col)
 
plot.cols <- names(sum.dat)[c(4:20)]
plot.cols

### Reorder summary data and SAVE
     
    sum.dat <- do.reorder(sum.dat, group.col, grp.order)
    sum.dat[,c(1:3)]
     
    fwrite(sum.dat, 'sum.dat.csv')
    
    ##Violin/scatterplots
    ### Autographs
 
    for(i in plot.cols){
         
        measure <- gsub("\\ --.*", "", i)
        measure
         
        pop <- gsub("^[^--]*.-- ", "", i)
        pop
         
        make.autograph(sum.dat,
                       x.axis = group.col,
                       y.axis = i,
                       y.axis.label = measure,
                       violin = FALSE,
                       colour.by = batch.col,
                        
                       grp.order = grp.order,
                       my_comparisons = comparisons,
                        
                       Variance_test = variance.test,
                       Pairwise_test = pairwise.test,
                        
                       title = pop,
                       subtitle = measure,
                       filename = paste0(i, '.pdf'))
         
    }
    
    ##Heatmaps
    ### Create a fold change heatmap
     
    ## Z-score calculation
    sum.dat.z <- do.zscore(sum.dat, plot.cols)
     
    ## Group
    t.first <- match(grp.order, sum.dat.z[[group.col]])
    t.first <- t.first -1
    t.first
     
    ## Make heatmap
    make.pheatmap(sum.dat.z,
                  sample.col = sample.col,
                  plot.cols = paste0(plot.cols, '_zscore'),
                  is.fold = TRUE,
                  plot.title = 'Z-score',
                  annot.cols = annot.cols,
                  dendrograms = 'column',
                  row.sep = t.first,
                  cutree_cols = 3)
    
    

```


###7.a. Cytofkit2/PhenoGraph setup script
```{r}
#Load Packages
library(cytofkit2)
library(job)
library(data.table)

#Set directory and if need to, re-mport logicle-transformed and batch aligned csv file (from cytonorm/spectre)
setwd("W:/Collaborative Projects/BSNRF/Spectre/Comparison of DR and UMAP to cytofkit2/cytofkit2 attempt 2")
getwd()

combined.data.transformed <- fread("aligned.cell.edited.csv")

#Otherwise for simplicity, simply rename the object:
#combined.data.transformed <- cell.dat
```


###7.b. Phenograph Cluster analysis - WARNING - Run time can be high for large datasets
First, we will cluster the data to identify populations that partition together as similar cells in high-dimensional space. Initially, we identify parameters - used for both clustering analysis and for the dimensionality reduction. We will use PhenoGraph AND flowSOMfor cluster analysis and save these in their respective objects. 
```{r}
#Identify aligned and transformed data for analysis
data_transformed <- combined.data.transformed[,c(1:27)]
colnames(data_transformed)


#Decide if internal control samples will be included as sample in clustering or not:
#Otherwise Ensure internal control samples all removed from dataset:
#data_transformed <- data_transformed[!grepl("IC5", data_transformed$FileName), ]


#Run cell subset identification
clust.params <- data_transformed[,c(4, 6:11, 13, 15, 17:27)]
colnames(clust.params)
dim(clust.params)

#Memory saving steps:
#Remove unused objects
rm(combined.data.transformed)

###NOTE: This next step can be RAM/CPU intensive depending on data size - ensure access to VM/able to run in background 

#Run function as background job to free up environment
job::job({cluster_PhenoGraph <- cytof_cluster(xdata = clust.params, 
                                    method = "Rphenograph",
                                    Rphenograph_k = 30)}) #Decide on Rphenograph_k depending on expected cluster number

#Savepoint
write.csv(clust.params, file = "cytofkit_clust.params.csv")

```


###7.c. Dimensionality reduction ~ WARNING - This step may also have long run time!
To visualise cell subsets defined by PhenoGraph, we will embed the high dimensional data in two dimensional space, using uniform manifold approximation and projection embedding (UMAP).
```{r, eval=FALSE}

#Run dim reduction as background job
umap.params <- data_transformed[,c(4, 6:11, 13, 15, 17:27)]

job::job({data_transformed_umap <- cytof_dimReduction(data = umap.params,
                                            markers = colnames(umap.params),
                                            method = "umap",
                                            umap_neighbour = 30, #decide on UMAP_neighbour based on expected n clusters
                                            umap_min_dist = 0.1) #decide on UMAP_min_dist based on complexity of UMAP
})
  


```

###7.d. Append and export Phenograph data as csv
FlowSOM, PhenoGraph and UMAP have calculated and assigned a discrete variable for each cell (row). We now append these data to the logicle-transformed data using column bind.

```{r, eval=FALSE}
#Append clustering and dim reduction data to fluorescence data
data_all <- cbind(data_transformed, data_transformed_umap, 
                     PhenoGraph = cluster_PhenoGraph)
#Export as csv file
data_all <- as.data.frame(data_all)
write.csv(data_all, file = "cytofkit_experiment_analysis.csv")
```

###7.e. Calculate mean logicle-transformed fluorescence intensities for each subset
For visual analysis of each flowSOM or PhenoGraph cluster, we use the code below to calculate the logicle-transformed, mean fluorescence intensities for each flowSOM metacluster or PhenoGraph cluster.

```{r, eval=FALSE}
#Export mean expression data for each cluster
mean.expression.PhenoGraph <- cytof_clusterStat(data_all, cluster = "PhenoGraph", statMethod = "mean")
write.csv(mean.expression.PhenoGraph, file = "cytofkit_meanexpression_analysis.csv")
```

## 7.f. Append and write to .fcs
Finally we append the UMAP, PhenoGraph and flowSOM data to the original dataset and save this in fcs file format using cytof_addToFCS function if wish to visualise in FlowJo.

```{r, eval=FALSE}
#Append clustering and dim reduction data to fluorescence data
cytof_addToFCS(data_all, rawFCSdir=dir, analyzedFCSdir=dir, 
               transformed_cols = c("umap_1", "umap_2"), 
               cluster_cols = c("PhenoGraph"))
```

## 7.g. Save R data
```{r, eval=FALSE}
save.image(file = "CIS_analysis.RData")
# load("CIS_analysis.RData")
```


### 7.h.) Merge Cytofkit outputs

```{r}

#read in logicle transformed expression data if reimporting
#allexpression.data <- read.csv(file = "cytofkit_experiment_analysis.csv", quote = "")

#otherwise just relabel:
allexpression.data <- data.all

#get relevant (compensated) expression data
expression.data <- allexpression.data[]
colnames(expression.data)

#clean up column names
colnames(expression.data) <- c("Number", "Event", "Group", "Batch", "CD45RB", "CD79b", "IgA",
                               "CD71", "IgG2 + IgG3", "IgM", "CD38",
                               "CXCR5", "HLA-DR", "CD24", "EBNA-1 BUV737", "CD19", "EBNA-1 BV421",
                               "CD21", "CD20", "BAFF-R", "CD11c",
                               "IgG", "CD27", "IgG1 + IgG3", "CD86",
                               "CD10", "IgD", "CXCR3",
                               "umap_1", "umap_2", "PhenoCluster"
                               )
colnames(expression.data)
rm(allexpression.data)


# Specify the desired column order if wish
desired_order <- c("Number", "Event", "Group", "Batch", "CD19", "CD20", "CD21", "CD24", "CD38", 
                   "CD27", "IgD",  "CD10", "CD45RB", "CD79b", "IgA",
                   "CD71",   "IgG",  "IgG1 + IgG3", "IgG2 + IgG3", 
                   "IgM", "CD11c", "CXCR3",  "CXCR5",  "CD86",
                   "BAFF-R", "HLA-DR", "EBNA-1 BUV737","EBNA-1 BV421",
                   "umap_1", "umap_2", "PhenoCluster"
)

# Rearrange the columns based on the desired order
expression.data <- expression.data[, desired_order]

# Check the new column order
colnames(expression.data)

#Write csv to check
write.csv(expression.data, file = "cytofkit_expression_rearrangedcol.data.csv")

```


##7.i.) Visualisation of the Dimension Reduced data

```{r pressure, echo=FALSE}
library(ggplot2)
library(ggsci)
library(viridis)

#create colour palette for discrete variables (phenoclusters) - keep in mind number of clusters and adjust; here are 26 unique colours:
  My_pal <-  c(
  "dodgerblue2", "#E31A1C", # red
  "green4",
  "#6A3D9A", # purple
  "#FF7F00", # orange
  "black", "gold1",
  "skyblue2", "#FB9A99", # lt pink
  "palegreen2",
  "#CAB2D6", # lt purple
  "#FDBF6F", # lt orange
  "gray70", "khaki2",
  "maroon", "orchid1", "deeppink1", "blue1", "steelblue4",
  "darkturquoise", "green1", "yellow4", "yellow3",
  "darkorange4", "brown", "#25C98C" #teal
)

#visualise concatenated data
p1 <- ggplot(expression.data, aes(x = umap_1,
                                y = umap_2,
                                colour = factor(PhenoCluster))) + 
                                geom_point(size = 0.05, show.legend = TRUE) +
                                theme_light() +
                                scale_colour_manual("PhenoCluster", values = My_pal) +
                                guides(colour = guide_legend(override.aes = list(size = 5), ncol = 2)) + 
                                xlab("UMAP 1") + ylab("UMAP 2")

p1

#Export data for analysis
jpeg(filename = "Interim_panel_PhenoCluster_altcolourpal.jpg", width = 8, height = 7, units = 'in', res = 600)
p1
dev.off()
```


## 7.j.) Multiplots
```{r}
library(cowplot)
library(viridis)

# Create a vector of characters for each marker/parameter that were included:
parameter.types <- colnames(expression.data[, c(5:28
                                                )])

# Create function that will construct a t-SNE scatter plot that displays parameter expression in the colour mapping
multiplots <- function(i) {
                          colour <- expression.data[[i]]
                          ggplot(expression.data, aes(x = umap_1, y = umap_2)) +
                          ggtitle(colnames(expression.data[i],
                                           )) +
                          geom_point(size = 0.1,
                          aes(colour = colour),
                              show.legend = FALSE) +
                          theme_classic() +
                          theme(plot.title = element_text(size = 24, face = "bold")) +
                          scale_colour_gradientn(
                                                 "MFI",
                                                 colours = c("black", inferno(4)),
                                                 limits = c(-1, 5), #Adjust limits to desired range of gradient
                                                 breaks = c(seq(
                                                                from = 1, to = 5, by = 1
                                                 ))
                                                 ) +
                          ylim(c(-10, 15)) + xlim(c(-10, 15)) + xlab("UMAP 1") + ylab("UMAP 2") #Adjust xylimits
                          }

# Iterate function through each element of the character vector
markerexpression <- lapply(parameter.types, multiplots)

# Create multiplots with cowplot, calling on list of ggplot objects created through lapply()
plotmarkerexpression <- plot_grid(plotlist = markerexpression,
                                  ncol = 8,
                                  align = "hv")
 
# export hi res jpeg
jpeg("Expression data - Multiplots- scale adjusted 0 to 4.jpg", width = 40, height = 15, units = 'in', res = 300)
plotmarkerexpression
dev.off()
```

## 7.k.) Cluster Annotations
```{R, fig.width=8, fig.align="center", message=FALSE}

library(dplyr)
library(stringr)
library(viridis)
library(ggsci)
library(ggplot2)
library(MetBrewer)

# create new data table 
annotate.data1 <- expression.data %>% mutate(prefix_tag = sub("^", "Pheno_", expression.data$PhenoCluster))

annotate.data2 <- annotate.data1 %>% mutate(suffix_tag = sub("$", "_clust", annotate.data1$prefix_tag)) %>% 
                  mutate(Cell_ID = str_replace_all(suffix_tag,c("Pheno_1_clust" = "1_Mature Naive",
                                                                 "Pheno_2_clust" = "2_Mature Naive",
                                                                 "Pheno_3_clust"= "3_CD24lo Naive",
                                                                 "Pheno_4_clust" = "4_MZP",
                                                                 "Pheno_5_clust" = "5_IgA+ swMBC",
                                                                 "Pheno_6_clust" = "6_IgG3+ CD11c+/- MZ",
                                                                 "Pheno_7_clust"= "7_CXCR3+ Naive",
                                                                 "Pheno_8_clust" = "8_Possible plasma cells",
                                                                 "Pheno_9_clust" = "9_CD79blo T2",
                                                                 "Pheno_10_clust" = "10_IgG1+ swMBC",
                                                                 "Pheno_11_clust" = "11_T2",
                                                                 "Pheno_12_clust"= "12_IgM-only MBC",
                                                                 "Pheno_13_clust" = "13_IgG2+ swMBC",
                                                                "Pheno_14_clust" = "14_CXCR3+ MZB",
                                                                "Pheno_15_clust" = "15_Unsw/MZB",
                                                                "Pheno_16_clust" = "16_Atypical CD11c+CD21lo MBC",
                                                                "Pheno_17_clust" = "17_IgM+ Plasmablasts",
                                                                "Pheno_18_clust" = "18_CXCR3+ IgG1 swMBC",
                                                                "Pheno_19_clust" = "19_T1",
                                                                "Pheno_20_clust" = "20_CD11c+ Naive",
                                                                "Pheno_21_clust" = "21_CD71+CXCR3+ Naive",
                                                                "Pheno_22_clust" = "22_IgM- Plasmablasts",
                                                                "Pheno_23_clust" = "23_CD10+IgG3+ MBC",
                                                                "Pheno_24_clust" = "24_CD10+IgA+ swMBC",
                                                                "Pheno_25_clust" = "25_CD86hi swMBC",
                                                                "Pheno_26_clust" = "26_IgM- swMBC"
                                                                )))

#Visualise the annotated concatenated data
 My_pal <- c(pal_igv()(26))
names(My_pal) = factor(unique(annotate.data2$Cell_ID))

p2 <- ggplot(annotate.data2, 
             aes(x = umap_1,
                 y = umap_2,
                 colour = Cell_ID)) +
      geom_point(size = 0.1, show.legend = TRUE) +
      theme_classic() + xlab("UMAP 1") + ylab("UMAP 2") +
      scale_colour_manual("Cell_ID", values = c(My_pal)) +
      guides(colour = guide_legend(override.aes = list(size = 5), ncol = 1))

p2

jpeg("Annotated clusters.jpg", width = 11, height = 8, units = 'in', res = 300)
p2
dev.off()

write.csv(annotate.data3, file = "annotated.data.cytofkit2.csv", row.names = FALSE)
```


## 7.l.) Subset UMAP by batch or sample type
```{r}
library(dplyr)
library(cowplot)

samplenames <- c("MS", "HC", "IC") #adjust according to sample ID for type

my_pal <- c(
  "dodgerblue2", "#E31A1C", # red
  "green4",
  "#6A3D9A", # purple
  "#FF7F00", # orange
  "black", "gold1",
  "skyblue2", "#FB9A99", # lt pink
  "palegreen2",
  "#CAB2D6", # lt purple
  "#FDBF6F", # lt orange
  "gray70", "khaki2",
  "maroon", "orchid1", "deeppink1", "blue1", "steelblue4",
  "darkturquoise", "green1", "yellow4", "yellow3",
  "darkorange4", "brown", "#25C98C" #teal
)

# Create a list to store subsets of data for each group
samplelist <- list()
for (i in unique(samplenames)) {
  samplelist[[i]] <- annotate.data2 %>% filter(grepl(i, Event))
}

# Define function to create plots for each group
subsetplots <- function(i) {
  ggplot(samplelist[[i]], aes(
    x = umap_1,
    y = umap_2,
    colour = factor(Cell_ID)
  )) +
    ggtitle(i) +  # Add title based on group name
    geom_point(size = 0.1, show.legend = TRUE) +
    theme_classic() + xlab("UMAP 1") + ylab("UMAP 2") +
    theme(legend.text = element_text(size = 12),
          legend.position = "none") +
    scale_colour_manual("Cell ID", values = my_pal) +
    guides(colour = guide_legend(override.aes = list(size = 5), ncol = 2))
}

# Create plots for each group
multiplot <- lapply(samplenames, subsetplots)

# Arrange plots in a grid
p3 <- plot_grid(plotlist = multiplot,
                ncol = 2,
                align = "hv",
                labels = "",
                label_size = 14
)

# Save the plot to a JPEG file
jpeg("EBNA1 CIS and HC subsetted.jpg", width = 15, height = 7.5, units = 'in', res = 300)
p3
dev.off()




#########Subset by batch (manual) IC samples ONLY

library(dplyr)
library(cowplot)


library(ggplot2)
library(gridExtra)

##First filter by internal control samples only:

# Make a copy of annotate.data2
annotate.data3 <- annotate.data2

# Remove double quotes from Group column in the copied dataframe
annotate.data3$Group <- gsub("\"", "", annotate.data3$Group)

# Trim whitespace from Group column
annotate.data3$Group <- trimws(annotate.data3$Group)

# Filter rows where Group is "IC"
IC_subset <- annotate.data3 %>%
  filter(Group == "IC")

# Printing the subset
print(IC_subset)

batchnames <- c("A", "B", "C", "D", "E", "F", "G", "H", "I")

#create colour palette for discrete variables (phenoclusters)
  My_pal <-  c(
   "dodgerblue2", 
   "#E31A1C", # red
   "green4",
   "#6A3D9A", # purple
   "#FF7F00", # orange
   "black", 
   "gold1",
   "skyblue2", 
   "#FB9A99", # lt pink
   "palegreen2",
   "#CAB2D6", # lt purple
   "#FDBF6F", # lt orange
   "gray70", 
   "khaki2",
   "maroon", 
   "orchid1", 
   "deeppink1", 
   "blue1", 
   "steelblue4",
   "darkturquoise", 
   "green1", 
   "yellow4", 
   "yellow3",
   "darkorange4", 
   "brown", 
   "#25C98C" #teal
)

samplelist <- list()
for (i in unique(batchnames)) {
  samplelist[[i]] <- IC_subset %>% filter(grepl(i, Batch))
}

subsetplots <- function(i) {
  ggplot(samplelist[[i]], aes(
    x = umap_1,
    y = umap_2,
    colour = factor(Cell_ID)
  )) +
    geom_point(size = 0.5, show.legend = TRUE) +
    theme_classic() + xlab("UMAP 1") + ylab("UMAP 2") +
    theme(legend.text = element_text(size = 12),
          legend.position = "none") +
    scale_colour_manual("Cell ID", values = My_pal) +
    guides(colour = guide_legend(override.aes = list(size = 5), ncol = 2)) +
    ggtitle(paste("Batch", i))  # Add title based on batch name
}

multiplot <- lapply(sort(batchnames), subsetplots)  # Sort batchnames alphabetically
p3 <- plot_grid(plotlist = multiplot,
                ncol = 2,
                align = "hv",
                labels = "",
                label_size = 14
)

jpeg("IC Batch subsetted.jpg", width = 25, height = 25, units = 'in', res = 300)
print(p3)  # Print the plot to the jpeg file
dev.off()



```

###7.m.) Export cluster data as frequencies and proportions
```{r}

##Calculate frequencies and proportions of each cluster by MS and controls:
# Filter the dataframe to include only MS and HC groups
filtered_df <- subset(annotate.data3, Group %in% c("MS", "HC"))

# Calculate frequencies of Cell_ID types within each group
freq_table <- table(filtered_df$Group, filtered_df$Cell_ID)

# Convert frequency table to dataframe
freq_df <- as.data.frame.matrix(freq_table)

# Calculate total counts for each group
total_counts <- rowSums(freq_df)  # Sum by rows (group-wise)

# Calculate frequency as a proportion of total counts for each group
freq_proportions <- freq_df / total_counts

# Bind frequencies and proportions together
combined_df <- rbind(freq_df, freq_proportions)

# Name the new rows
rownames(combined_df)[nrow(combined_df) - 1] <- "HC Proportion"
rownames(combined_df)[nrow(combined_df)] <- "MS Proportion"

# Write combined dataframe to a CSV file
write.csv(combined_df, file = "frequency_comparison.csv")

# Confirm file creation
cat("CSV file 'frequency_comparison.csv' has been created.")

library(ggplot2)
library(tidyr)

# Assuming your dataframe is named 'frequency_comparison'
# Melt the dataframe to long format
# Remove the first two rows
frequency_comparison <- frequency_comparison[-c(1, 2), ]

frequency_comparison_long <- gather(frequency_comparison, key = "B_cell_type", value = "Value", -...1)

# Plot grouped bar graph
ggplot(frequency_comparison_long, aes(x = B_cell_type, y = Value, fill = ...1)) +
  geom_bar(stat = "identity", position = position_dodge()) +
  labs(title = "B Cell Types Comparison",
       x = "B Cell Type",
       y = "Proportion",
       fill = "Group") +
  theme_light() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))


```