---
title: "Spectre attempt 4"
author: "https://github.com/saeyslab/CytoNorm"
date: "2024-02-15"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


#### 1. Load packages, and set working directory
```{r }
#### 1. Load packages, and set working directory

### Install CytoNorm package
     
      library(devtools)
        install_github('saeyslab/CytoNorm')
 
### Load libraries
 
        library(Spectre)
        Spectre::package.check()    # Check that all required packages are installed
        Spectre::package.load()     # Load required packages
        
        
### Set PrimaryDirectory
    dirname(rstudioapi::getActiveDocumentContext()$path)            # Finds the directory where this script is located
    setwd(dirname(rstudioapi::getActiveDocumentContext()$path))     # Sets the working directory to where the script is located
    getwd()
    PrimaryDirectory <- getwd()
    PrimaryDirectory
    
    
### Set 'input' directory
    setwd(PrimaryDirectory)
    setwd("data/")
    InputDirectory <- getwd()
    setwd(PrimaryDirectory)  
    
### Set 'metadata' directory
    setwd(PrimaryDirectory)
    setwd("metadata/")
    MetaDirectory <- getwd()
    setwd(PrimaryDirectory)   
    
    
### Create output directory
    dir.create("Output_Spectre", showWarnings = FALSE)
    setwd("Output_Spectre")
    OutputDirectory <- getwd()
    setwd(PrimaryDirectory)    

```


#### 2. Import and prep data

```{r}
#### 2. Import and prep data



### Import data
 
    setwd(InputDirectory)
    list.files(InputDirectory, ".csv")
    
    

data.list <- Spectre::read.files(file.loc = InputDirectory,
                                 file.type = ".csv",
                                 do.embed.file.names = TRUE)


### Check the data
 
    check <- do.list.summary(data.list)
 
    check$name.table # Review column names and their subsequent values
    check$ncol.check # Review number of columns (features, markers) in each sample
    check$nrow.check # Review number of rows (cells) in each sample
    
    

data.list[[1]]



### Merge data
 
    cell.dat <- Spectre::do.merge.files(dat = data.list)
    
    
    cell.dat


### Read in metadata 
    setwd(MetaDirectory)
     
    meta.dat <- fread("sample.details.csv")
    meta.dat
    
    

```



#### 3. Data transformation
```{r}
  
#### 3. LOGICLE Data transformation

setwd(OutputDirectory)
    dir.create("Output 1 - transformed plots")
    setwd("Output 1 - transformed plots") 
    
 #Pre-transformation plots
    
    
   sub <- do.subsample(cell.dat, 10000)
    
        as.matrix(names(sub))
 
transf.cols <- names(sub)[grepl('Ig|CX|CD|BAFF|HLA', names(sub))] #Run through "Ig", "CX", "CD", "BAFF" and "HLA" to ensure all                                                       markers are plotted for this
as.matrix(transf.cols)

   plot.against <- 'CD19 BUV805'       # Choose the y-axis column for each plot
   which(names(sub) == plot.against)       # Check that the selected column name is actually present
 
   for(i in transf.cols){
      make.colour.plot(sub, i, plot.against)
   }
   
   #Commence transformation
    
    use.cols = names(cell.dat)[c(3:26)]
    dat.lgcl = do.logicle(cell.dat, use.cols = use.cols)
    
    do.logicle <- function(cell.dat, 
                       use.cols,
                       auto.infer.function = FALSE,
                       linearisation.width = 1.2,
                       max.scale.val = 262144,
                       full.transform.width = 4.5,
                       additional.negative.range = 0) {
  
  require(flowCore)
  require(Biobase)
  require(data.table)
  
  # check selected columns are numeric
  if(any(unlist(lapply(dat[, use.cols, with = FALSE], is.numeric)) == FALSE)) {
    stop('Non-numeric columns are selected for transformation. Please exclude them.')
  }
  
  values <- dat[,use.cols, with=FALSE]
  
  val.mat <- as.matrix(values)
  
  ff <- new("flowFrame", exprs = val.mat)
  
  if (auto.infer.function) {
    # Automatic estimated logicle function
    message("Automatically estimating the logicle transformation function based on input data")
    lgcl <- estimateLogicle(ff, channels = use.cols) 
  } else {
    
    # check parameter conditions, make sure they are greater than 0
    if (is.null(max.scale.val) || max.scale.val <= 0) {
      stop('max.scale.val must be greater than 0')
    }
    if (is.null(linearisation.width) || linearisation.width <= 0) {
      stop('linearisation.width must be greater than 0')
    }
    if (is.null(full.transform.width) || full.transform.width <= 0) {
      stop('full.transform.width must be greater than 0')
    }
    
    # User defined logicle function
    message("Formulating logicle transformation function")
    trans_lgcl <- logicleTransform(w = linearisation.width, 
                                   t = max.scale.val, 
                                   m = full.transform.width, 
                                   a = additional.negative.range)
    lgcl <- transformList(use.cols, trans_lgcl)
  }
  
  # Do transformation
  message("Transforming data")
  trans.val <- flowCore::transform(ff, lgcl)
  
  message("Converting data back to data.table")
  trans.val.dt <- data.table(exprs(trans.val))
  names(trans.val.dt) <- paste(names(trans.val.dt), "logicle", sep = "_")
  
  dat_copy <- cbind(dat, trans.val.dt)
  return(dat_copy)
}

    
    # Make plots of transformed columns from the subsampled data
    

   sub <- do.subsample(dat.lgcl, 10000)
    
        as.matrix(names(sub))
 
transf.cols <- names(sub)[grepl('_logicle', names(sub))]
as.matrix(transf.cols)

   plot.against <- 'CD19 BUV805_logicle'       # Choose the y-axis column for each plot
   which(names(sub) == plot.against)       # Check that the selected column name is actually present
 
   for(i in transf.cols){
      make.colour.plot(sub, i, plot.against)
   }
   getwd()
   
   fwrite(dat.lgcl, 'logicle_transformed_cell.dat.csv')
   
   cell.dat <- dat.lgcl
   rm(dat.lgcl)
```


#### 4. Add metadata and set some preferences

```{r}
#### 4. Add metadata and set some preferences
### Add metadata to data.table
 
    meta.dat


sample.info <- meta.dat[,c(1:4)]
sample.info



cell.dat <- do.add.cols(cell.dat, "FileName", sample.info, "FileName", rmv.ext = TRUE)


cell.dat

### Define cellular columns
    as.matrix(names(cell.dat))
    

### Define cellular columns
 
    as.matrix(names(cell.dat))
 
    cellular.cols <- names(cell.dat)[c(29:52)]
    as.matrix(cellular.cols)
    
### Define clustering columns   
      
     as.matrix(names(cell.dat))
 
     cluster.cols <- names(cell.dat)[c(29, 33:36, 38, 40, 42:44, 46:52)]
     as.matrix(cluster.cols)
     
     
### Define other key columns
     
    as.matrix(names(cell.dat))
 
    exp.name <- "MS experiment"
     
    sample.col <- "Sample"
    group.col <- "Group"
    batch.col <- "Batch"
    
    
### Subsample targets per group
 
    data.frame(table(cell.dat[[group.col]])) # Check number of cells per sample.
    
 as.matrix(unique(cell.dat[[group.col]]))
 
 sub.targets <- c(50000, 50000, 50000) # target subsample numbers from each group
sub.targets



```


#### 5. Batch alignment
```{r}

#### 5. Batch alignment

setwd(OutputDirectory)
dir.create("Output 2 - alignment")
setwd("Output 2 - alignment")

### Extract reference samples
     
    sample.info
    
    as.matrix(unique(cell.dat[[sample.col]]))
    refs <- unique(cell.dat[[sample.col]])[c(29:37)]
refs
ref.dat <- do.filter(cell.dat, sample.col, refs)
ref.dat

### Initial clustering
     
    setwd(OutputDirectory)
    setwd("Output 2 - alignment")
    dir.create("1 - ref pre-alignment")
    setwd("1 - ref pre-alignment")
    
 trace(FlowSOM::AggregateFlowFrames, edit = T) ##replace all & with && (SEE TEXTFILE)
 #trace(Spectre::prep.cytonorm, edit = T)
 
 cytnrm <- prep.cytonorm(dat = ref.dat,
                        cellular.cols = cellular.cols,
                        cluster.cols = cluster.cols,
                        batch.col = batch.col,
                        sample.col = sample.col)        
 
cytnrm


cytnrm.sub <- do.subsample(cytnrm$dt, 10000)
cytnrm.sub <- run.umap(cytnrm.sub, use.cols = cluster.cols)

make.colour.plot(cytnrm.sub, 'UMAP_X', 'UMAP_Y', 'prep.fsom.metacluster', 'factor', add.label = TRUE)


make.colour.plot(cytnrm.sub, 'UMAP_X', 'UMAP_Y', 'File', 'factor')


### Alignment
     
    setwd(OutputDirectory)
    setwd("Output 2 - alignment")
    
    trace(Spectre::train.cytonorm, edit = T) #make sure all iterations of model$fsom actually replaced with model$fsom$FlowSOM (SEE TEXTFILE)
 cytnrm <- train.cytonorm(model = cytnrm, align.cols = cellular.cols)   
 
  
 trace(Spectre::run.cytonorm, edit = T) #make sure all iteration of model$fsom actually replaced with model$fsom$FlowSOM (SEE TEXTFILE)
cell.dat <- run.cytonorm(dat = cell.dat, model = cytnrm, batch.col = batch.col)
  
  
  
aligned.cols <- paste0(cellular.cols, '_aligned')

setwd(OutputDirectory)
     setwd("Output 2 - alignment")
     dir.create("3 - all aligned")
     setwd("3 - all aligned")

fwrite(cell.dat, 'aligned.cell.dat.csv')

### Plotting reference data
     
    setwd(OutputDirectory)
    setwd("Output 2 - alignment")
    dir.create("2 - ref aligned")
    setwd("2 - ref aligned")
    
    
    ref.sub <- do.filter(cell.dat, sample.col, refs)
ref.sub



ref.sub <- do.subsample(ref.sub, 50000)
ref.sub <- run.umap(ref.sub, use.cols = aligned.cols)



make.colour.plot(ref.sub, 'UMAP_X', 'UMAP_Y', batch.col, 'factor')


make.colour.plot(ref.sub, 'UMAP_X', 'UMAP_Y', 'Alignment_MC_aligned', 'factor', add.label = TRUE)


make.colour.plot(ref.sub, 'UMAP_X', 'UMAP_Y', sample.col, 'factor')


make.colour.plot(ref.sub, 'UMAP_X', 'UMAP_Y', group.col, 'factor')



### Plotting all data
      
     setwd(OutputDirectory)
     setwd("Output 2 - alignment")
     dir.create("3 - all aligned")
     setwd("3 - all aligned")
     
     
     aligned.sub <- do.subsample(cell.dat, 50000)
aligned.sub <- run.umap(aligned.sub, use.cols = aligned.cols)


make.colour.plot(aligned.sub, 'UMAP_X', 'UMAP_Y', batch.col, 'factor')


make.colour.plot(aligned.sub, 'UMAP_X', 'UMAP_Y', 'Alignment_MC_aligned', 'factor', add.label = TRUE)


make.colour.plot(aligned.sub, 'UMAP_X', 'UMAP_Y', sample.col, 'factor')

make.colour.plot(aligned.sub, 'UMAP_X', 'UMAP_Y', group.col, 'factor')


fwrite(aligned.sub, 'aligned.sub.csv')
```

#### 6. Clustering and dimensionality reduction

```{r}
#### 6. Clustering and dimensionality reduction

cell.dat <- fread("clustered.data_edited.csv")
setwd(OutputDirectory)
dir.create("Output 3 - clustering")
setwd("Output 3 - clustering")


### Re-set cellular and clustering cols
 
    aligned.cellular.cols <- paste0(cellular.cols, '_aligned')
    aligned.cellular.cols
     
    aligned.cluster.cols <- paste0(cluster.cols, '_aligned')
    aligned.cluster.cols
    
    
### Clustering
 
    cell.dat <- run.flowsom(cell.dat, aligned.cluster.cols, meta.k = 50)
    fwrite(cell.dat, "clustered.data.csv")
    
    

### Dimensionality reduction
 
    cell.sub <- do.subsample(cell.dat, sub.targets, group.col)
    cell.sub <- run.umap(cell.sub, aligned.cluster.cols)
 
    fwrite(cell.sub, "clustered.data.DR.csv")
    
    

### DR plots
 
    make.colour.plot(cell.sub, "UMAP_X", "UMAP_Y", "FlowSOM_metacluster", col.type = 'factor', add.label = TRUE)
    
    make.multi.plot(cell.sub, "UMAP_X", "UMAP_Y", aligned.cellular.cols)
    
    make.multi.plot(cell.sub, "UMAP_X", "UMAP_Y", "FlowSOM_metacluster", group.col, col.type = 'factor')

### Expression heatmap
 
    exp <- do.aggregate(cell.dat, aligned.cellular.cols, by = "FlowSOM_metacluster")
    make.pheatmap(exp, "FlowSOM_metacluster", aligned.cellular.cols)

```

#Annotate Clusters
```{r}
#Annotate Clusters
cell.dat <- fread("clustered.data_edited.csv")
cell.sub <- fread("clustered.data.DR_edited.csv")
setwd(OutputDirectory)
dir.create("Output 4 - annotation")
setwd("Output 4 - annotation")

### Annotate
 
    annots <- list("IgG1+ swMBC" = c(1, 12, 19, 20),
                   "Unknown" = c(2, 15, 18, 22, 33, 37, 38, 39, 43, 47),
                   "IgG+ MBC" = c(3),
                   "CD71hi IgA+ SwMBC" = c(4),
                   "Plasmablasts" = c(5, 6),
                   "Atypical CD11c+ CD21lo" = c(7, 16, 21),
                   "Naive B cells" = c(8, 9, 10, 32, 42, 44),
                   "CXCR3+ IgG+ Naive B cells" = c(11),
                   "IgG1 MBC" = c(13),
                   "IgG+ CD86hi CD71hi swMBC" = c(14),
                   "IgG2+ swMBC" = c(17, 23, 25),
                   "IgG+ swMBC" = c(24),
                   "IgA+ swMBC" = c(26, 27, 28, 30, 31),
                   "MZB" = c(29, 48, 49),
                   "IgM+ swMBC" = c(34, 35, 36, 41),
                   "CXCR3+CXCR5+ Naive B cell" = c(40),
                   "Transitional B cells" = c(45, 46, 50)
                   
                   
    )
    
    annots <- do.list.switch(annots)
names(annots) <- c("Values", "Population")
setorderv(annots, 'Values')
annots

### Add annotations

    cell.dat <- do.add.cols(cell.dat, "FlowSOM_metacluster", annots, "Values")
    cell.dat
     
    cell.sub <- do.add.cols(cell.sub, "FlowSOM_metacluster", annots, "Values")
    cell.sub

    
    
### Fill in NAs
      
     cell.dat[['Population']][is.na(cell.dat[, 'Population'])] <- 'Other'
     cell.dat
      
     cell.sub[['Population']][is.na(cell.sub[, 'Population'])] <- 'Other'
     cell.sub

     
     
### Save data and plots
     
    fwrite(cell.dat, "Annotated.data.csv")
    fwrite(cell.sub, "Annotated.data.DR.csv")
    
    make.colour.plot(cell.sub, "UMAP_X", "UMAP_Y", "Population", col.type = 'factor', add.label = TRUE, plot.width = 20, plot.height = 20, legend.loc = "bottom")
    
    do.filter(cell.sub, use.col = "Group", values = c("MS", "HC"))
make.multi.plot(cell.sub, "UMAP_X", "UMAP_Y", "Population", group.col, col.type = 'factor', plot.width = 20, plot.height = 20)

### Expression heatmap
     #Temporarily redefine cellular.cols:
 as.matrix(names(cell.dat))
 
    cellular.cols <- names(cell.dat)[c(4:27)]
    as.matrix(cellular.cols)
    aligned.cellular.cols <- cellular.cols

    rm(exp)
    exp <- do.aggregate(cell.dat, aligned.cellular.cols, by = "Population")
    make.pheatmap(exp, "Population", aligned.cellular.cols)
    
    
    
    
### Write FCS files
     
    setwd(OutputDirectory)
    setwd("Output 4 - annotation")
     
    dir.create('FCS files')
    setwd('FCS files')
     
    write.files(cell.dat,
                file.prefix = exp.name,
                divide.by = sample.col,
                write.csv = FALSE,
                write.fcs = TRUE)
    
    
```


#Summary data, graphs, statistics
```{r}
#### 8. Summary data and statistical analysis

setwd(OutputDirectory)
dir.create("Output 5 - summary data")
setwd("Output 5 - summary data")

### Setup
 
    variance.test <- 'kruskal.test'
    pairwise.test <- "wilcox.test"
 
    comparisons <- list(c("HC", "MS"))
    comparisons
     
    grp.order <- c("HC", "MS")
    grp.order
    
    
### Select columns to measure MFI
 
    as.matrix(aligned.cellular.cols)
    dyn.cols <- aligned.cellular.cols[c(5,8)]
    dyn.cols
    
    sum.dat <- create.sumtable(dat = cell.dat,
                           sample.col = sample.col,
                           pop.col = "Population",
                           use.cols = dyn.cols,
                           annot.cols = c(group.col, batch.col)
                           #counts = counts
                           )
    
    ### Review summary data
     
    sum.dat
    as.matrix(names(sum.dat))
    
    annot.cols <- c(group.col, batch.col)
 
plot.cols <- names(sum.dat)[c(4:21)]
plot.cols

### Reorder summary data and SAVE
     
    sum.dat <- do.reorder(sum.dat, group.col, grp.order)
    sum.dat[,c(1:3)]
     
    fwrite(sum.dat, 'sum.dat.csv')
    
    ##Violin/scatterplots
    ### Autographs
 
    for(i in plot.cols){
         
        measure <- gsub("\\ --.*", "", i)
        measure
         
        pop <- gsub("^[^--]*.-- ", "", i)
        pop
         
        make.autograph(sum.dat,
                       x.axis = group.col,
                       y.axis = i,
                       y.axis.label = measure,
                       violin = FALSE,
                       colour.by = batch.col,
                        
                       grp.order = grp.order,
                       my_comparisons = comparisons,
                        
                       Variance_test = variance.test,
                       Pairwise_test = pairwise.test,
                        
                       title = pop,
                       subtitle = measure,
                       filename = paste0(i, '.pdf'))
         
    }
    
    ##Heatmaps
    ### Create a fold change heatmap
     
    ## Z-score calculation
    sum.dat.z <- do.zscore(sum.dat, plot.cols)
     
    ## Group
    t.first <- match(grp.order, sum.dat.z[[group.col]])
    t.first <- t.first -1
    t.first
     
    ## Make heatmap
    make.pheatmap(sum.dat.z,
                  sample.col = sample.col,
                  plot.cols = paste0(plot.cols, '_zscore'),
                  is.fold = TRUE,
                  plot.title = 'Z-score',
                  annot.cols = annot.cols,
                  dendrograms = 'column',
                  row.sep = t.first,
                  cutree_cols = 3)
    
    

```

#Output session info
```{r}
### Session info and metadata
     
    setwd(OutputDirectory)
    dir.create("Output - info", showWarnings = FALSE)
    setwd("Output - info")
 
    sink(file = "session_info.txt", append=TRUE, split=FALSE, type = c("output", "message"))
    session_info()
    sink()
 
    write(aligned.cellular.cols, "cellular.cols.txt")
    write(aligned.cluster.cols, "cluster.cols.txt")
```

